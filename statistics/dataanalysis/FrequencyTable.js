/* copyright (c) 2012, Jim Armstrong.  All Rights Reserved. *  * THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. *  * This software may be modified for commercial use as long as the above copyright notice remains intact. */define(['../DataStats'], function (StatsModule) {  var returnedModule = function ()   {    var statsRef = new StatsModule();    var __stats  = new statsRef.DataStats();   /**    * A frequency table that is suitable for use with naieve Bayseian analysis or other applications where it is necessary to tabulate frequency    * of occurrences.  Cell data must be numeric (integral).    *    * Note:  Call the validate method before using table data in analysis - this will search for non-positive occurences, non-numeric cell data, etc.,    * and compensate by settin the frequency of occurrence to 1.    *    * @author Jim Armstrong    *     * @version 1.0    */    this.FrequencyTable = function()		{            this._table     = [];  // actual data table (array of arrays, stored column-major)      this._rowLabels = [];  // row labels      this._colLabels = [];  // column labels      this._rowTotals = [];  // row counts      this._colTotals = [];  // column counts      this._classSum = 0.0;      this._sumInvalidated = false; // true if class sum invalidated      this._invalidated    = false; // true if data invalidated		}        this.FrequencyTable.__name__ = true;    this.FrequencyTable.prototype =     {     /**      * Define a basic table that is empty and ready for dynamic input      *      * @param rowLabels : Array - List of row labels or classes (the row count is inferred from the length of this array)      *      * @param colLabels : Array - List of column labels (the column count is inferred from the length of this array)      *      * @return Nothing - The row and column labels are assigned and the table is initialized to zero counts.  Use the      * addCellCount() method to add cell counts to a cell (and adjust the row totals)      */      setupTable: function(rowLabels, colLabels)      {        if( !rowLabels || !colLabels )          return;        this.__clear();        this._rowLabels = rowLabels.slice();        this._colLabels = colLabels.slice();        var rows = this._rowLabels.length;        var cols = this._colLabels.length;        var i, j, col;                for( j=0; j<cols; ++j )        {          col = new Array(rows);          i   = rows;          while( --i >= 0 )           {            col[i] = 0;            this._rowTotals[i] = 0;          }          this._table[j] = col;        }        this._invalidated = true;      }     /**      * Assign the table from an array of arrays where each array represents a single row of data      *       * @param data : Array - Each element is an array containing one row of data and the first row is ALWAYS the category labels      *       * @param rowLabels : Array - Character labels for each row (class)      *      * @param colLabels : Array - Character labels for each column      *      * @param rowTotal : Array - Array of integer row counts indicating the total number of samples for each row or category,      * i.e. number of spam vs. non-spam messages.      *       * @return Nothing - The internal table is assigned provided that all input is valid, otherwise no data is assigned to the      * frequency table      */      , fromArray: function( data, rowLabels, colLabels, rowTotals )      {        if( !data || !rowLabels || !colLabels || !rowTotals)          return;                if( rowLabels.length != rowTotals.length )          return;        this.__clear();        var rows = rowLabels.length;        this._rowLabels = rowLabels.slice();        this._colLabels = colLabels.slice();        this._rowTotals = rowTotals.slice();        var n           = this._colLabels.length;        var i, y;        for( j=0; j<n; ++j )          this._table[j] = new Array();                for( i=0; i<rows; ++i )        {          if( data[i].length != n )            return;        }        // copy the data in, column-major        var j;        var row;        for( i=0; i<rows; ++i )        {          row = data[i];          for( j=0; j<n; ++j )            this._table[j].push( row[j] );        }        this.__columnTotals();      }     /**      * Access the table columns as a 2D array      *      * @return Array - 2D array of current table data, returned column-major      */      , get_tableData: function()      {        return this._table.slice();      }         /**      * Access the column labels      *       * @return Array - Array of column labels      */      , get_columnLabels: function()      {        return this._colLabels.slice();      }           /**      * Access the row labels      *       * @return Array - Array of row (class) labels      */      , get_rowLabels: function()      {        return this._rowLabels.slice();      }           /**      * Access the number of rows or data items per column      *       * @return Int - Number of rows      */      , get_itemCount: function()      {        if( this._table.length == 0 )          return 0;                return this._table[0].length;      }     /**      * Access the row counts       *       * @return Array - Array of row counts - this should be called after assigning data through individual cell frequencies      */      , get_rowTotals: function()      {        return this._rowTotals.slice();      }     /**      * Access the column counts       *       * @return Array - Array of column counts - this should be called after assigning data      */      , get_columnTotals: function()      {        if( this._invalidated )          this.__columnTotals();        return this._colTotals.slice();      }     /**      * Access the cumulative frequency of the all classes (sum of all row totals)      *      * @return Int - Total sum of all class occurrences (or sum reduction of row totals)      */      , get_classSum: function( )      {        if( this._sumInvalidated )        {          var sum = 0.0;          var i;          var row = this._rowTotals.length;          for( i=0; i<row; ++i )            sum += this._rowTotals[i];          this._sum = sum;          this._sumInvalidated = false;        }        return this._sum;      }           /**      * Access a single column of data as a standalone array      *       * @param label : String - column label      *       * @return Array - Copy of the current data in the specified column or an empty array if the category name is incorrect      */      , getColumn: function(label)      {        var index = this._colLabels.indexOf(label);        if( index == -1 )          return [];                  return this._table[index].slice();      }     /**      * Access class probability      *      * @param className : String - Class name or row label      *      * @return Number - Class probability - there is no error-checking on this method for performance reasons      */      , getClassProb : function(className)      {        var row = this._rowLabels.indexOf(className);        return this._rowTotals[row]/this.get_classSum();      }     /**      * Access the prior probability of a given predictor (column) given the colum name       *      * @param predictor : String - Column (predictor) label      *      * @return Number - Prior probability of the predictor - there is no error-checking on this method since it may be called      * frequently inside a loop      */      , getPrior: function(predictor)      {        if( this._invalidated )          this.__columnTotals();        var col = this._colLabels.indexOf(predictor);        return this._colTotals[col]/this.get_classSum();      }     /**      * Access the conditional probability of a class given a predictor      *      * @param className : String - Class name or row label      *      * @param predictor : String - Predictor name or column label      *      * @return Nothing - Conditional probability of the class given a predictor - there is no error-checking on this method since it      * may be called frequently inside a loop      */      , getConditional: function( predictor, className )      {        var col = this._colLabels.indexOf(predictor);        var row = this._rowLabels.indexOf(className)        var column = this._table[col];        return column[row]/this._rowTotals[row];      }     /**      * Remove a column from the current frequency table      *      * @param category : String - Column name or label      *      * @return Nothing - If the named column exists in the table, it is removed and all other columns are shifted left      */      , removeColumn : function(label)      {        var index = this._colLabels.indexOf(category);        if( index == -1 )          return;        this._table.splice(index, 1);      }     /**      * Add to the count in a specified cell      *      * @param rowLabel : String - Row label of cell      *      * @param colLabel : String - Column label of cell      *      * @param count : Int - Optional (positive) integer count to add to the frequency of the cell - this also updates the      * row count.  If not provided, the default count is 1      *      * @return Nothing - The cell frequency is updated provided that the row and colum names are accurate      */      , addCellFrequency: function( rowLabel, colLabel, count )      {        if( count == undefined )          count = 1;        count = Math.abs( Math.round(count) );        var row = this._rowLabels.indexOf(rowLabel);        var col = this._colLabels.indexOf(colLabel);        var column   = this._table[col];        column[row] += count;        this._invalidated    = true;        this._sumInvalidated = true;      }     /**      * Add to the row totals for an interactive experiement, i.e. where cell frequencies are updated dynamically      *      * @param rowLabel : String - Row or class label to which the frequency is added      *      * @param count : Int - Optional (positive) integer count to add to the frequency of the cell - this also updates the      * row count.  If not provided, the default count is 1      *      * @return Nothing - The row frequency is updated provided that inputs are valid      */      , addRowcount: function(rowLabel, count)      {        if( count == undefined )          count = 1;        count = Math.abs( Math.round(count) );        var row = this._rowLabels.indexOf(rowLabel);        this._rowTotals[row] += count;      }     /**      * Validate the frequency table data      *      * @param round : Boolean - True if an extra step is to be taken to round all cell data to nearest integer      *      * return Boolean - True if data is valid, as entered.  False if data is invalid, although many issues may be fixed via      * compensation.  Any instance of a non-numeric cell or non-positive count will be set to a frequency of 1.  If any cell      * value in a row exceeds the row count, it is clipped to the row count value.        */      , validate: function(round)      {        if( this._table.length     == 0 ||             this._rowLabels.length == 0 ||             this._colLabels.length == 0 ||             this._rowTotals.length == 0 )          return false;        if( round === undefined )          round = false;        var rows = this._rowLabels.length;        var n    = this._colLabels.length;        var i,j;        var item;        for( i=0; i<rows; ++i )        {          item = this._rowTotals[i];          if( isNaN(item) )            return false;          if( item < 1 )            return false;        }        var col;        var status = true;        for( j=0; j<n; ++j )        {          col = this._table[j];          for( i=0; i<rows; ++i )          {            if( isNaN(col[i]) || col[i] < 1 )            {              status = false;              col[i] = 1;            }            else if( col[i] > this._rowTotals[i] )            {              status = false;              col[i] = this._rowTotals[i];            }            if( round )              col[i] = Math.round( col[i] );          }        }        if( status )          this.__columnTotals();        return status;      }     /**      * Check correlatio between two columns      *       * @param column1 : String - Name of first column      *      * @param column2 : String - Name of second column      *      * @return Number - Pearson correlation between the numerical counts in the two columns.  This may be used to determine if two      * columns are sufficiently dependent (highly correlated) to consider removing one from Bayesian analysis.  Zero is returned      * if either column name is invalid.      */      , columnCorrelation: function(column1Label, column2Label)      {        var col1 = this._colLabels.indexOf(column1Label);        var col2 = this._colLabels.indexOf(column2Label);        if( col1 == -1 || col2 == -1 )          return 0.0;        return __stats.correlation( this._table[col1], this._table[col2] );      }      // internal method - update column totals      , __columnTotals: function()      {        var n    = this._colLabels.length;        var rows = this._rowLabels.length;        var i, j;        var col;        var sum;        for( j=0; j<n; ++j )        {          col = this._table[j];          sum = col[0];          for( i=1; i<rows; ++i )            sum += col[i];          this._colTotals[j] = sum;        }        this._invalidated = false;      }          // internal method - clear the current table and prepare for new input      , __clear: function()      {        this._table.length     = 0;        this._rowLabels.length = 0;        this._colLabels.length = 0;        this._rowTotals.length = 0;        this._colTotals.length = 0;        this._invalidated    = true;        this._sumInvalidated = true;      }    }  }    return returnedModule;});