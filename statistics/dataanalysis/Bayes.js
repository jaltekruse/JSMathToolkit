/* copyright (c) 2012, Jim Armstrong.  All Rights Reserved. *  * THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. *  * This software may be modified for commercial use as long as the above copyright notice remains intact. */define([], function () {  var returnedModule = function ()   {   /**    * A collection of methods for performing a variety of Bayesian analyses.    *    * NOTE: This class uses the ES6 Math.log2 function ( replace with log2 = log(x)/log(2) if needed )    *    * @author Jim Armstrong    *     * @version 1.0    */    this.Bayes = function()		{      this._table = null;    // reference to frequency table for naive Bayes       this._invalidated = false; // true if data invalidated		}        this.Bayes.__name__ = true;    this.Bayes.prototype =     {     /**      * Assign a data provider (frequency table) to be used to drive naive Bayes analysis      *      * @param freqTable : FrequencyTable - Reference to a frequency table      *      * @return Nothing - If the input reference is valid, assign the internal table reference      */      set_table: function(freqTable)      {        // a valid FrequencyTable should have a validate() method on its prototype chain        if( freqTable.__proto__.hasOwnProperty("validate") )        {          this._table = freqTable;          this._invalidated = true;        }      }    /**     * Perform a naieve Bayes analysis, i.e. compute P(c|X1...Xk) based on the supplied frequency table     *     * @param class : String - Class (or row name from the frequency table)     *     * @param predictors : Array - List of predictor (column labels) variables names from columns in the frequency table     *     * @param validate : Boolen - optional table validation parameter - if true, then run the validate() method on the frequency     * table before performing the analysis.  This can be useful for real-time updates to the table where data may need to be     * validated on-the-fly.     *     * @default false     *     * @param numeratorOnly : Boolean - optional parameter to evaluate the numerator only in the posterior probability calculation.     * This is useful for instances where the same predictors are used across two or more classes and comparisons are made across     * a common denominator     *     * @default false     *     * @param avoidUnderflow : Boolean - optional parameter to use an alternate computation method to avoid underflow or other     * numerical issues that result from the multiplication of a large number of very small values.       *     * @default false     *     * return Object - 'p' value contains P(c|X1...Xk) or -1 for invalid data.  The 'p' parameter may contain only the numerator     * of the necessary equation if the numeratorOnly input is true.  The 'gain' parameter is Kononenko information gain (only valid      * for full computation) and this property is only returend if data is valid.  For performance reasons, the predictors and class      * name are not checked, but bad data is almost always indicated by NaN for the requested probability.     *     * The set_table() method MUST be called to assign a data provider (frequency table) in advance of performing this analysis.      */     , naive: function( className, predictors, validate, numeratorOnly, avoidUnderflow )     {       if( !this._table )         return {p:-1};       if( !className || !predictors )         return {p:-1};       if( predictors.length == 0 )         return {p:-1};       if( validate === undefined )         validate = false;       if( numeratorOnly === undefined )         numeratorOnly = false;       if( avoidUnderflow === undefined )         avoidUnderflow = false;       if( validate )         this._table.validate();       var i, p, prob, col, cond, gain;       // total frequency for all classes and the specified class       var cf  = this._table.get_classSum();       var pc  = this._table.getClassProb(className);       var len = predictors.length;       // break out this case for performance       if( len == 1 )       {         // prior probability         p = this._table.getPrior( predictors[0] );         // conditional probability         cond = this._table.getConditional( predictors[0], className );         // result         prob = numeratorOnly ? cond*pc : (cond*pc)/p;       }       else       {         cond    = 1.0;         p       = 1.0;         var g   = [];         if( avoidUnderflow )         {           for( i=0; i<len; ++i )           {             g.push( this._table.getConditional( predictors[i], className ) );             cond += Math.log( g[i] );             p    *= numeratorOnly ? 1.0 : this._table.getPrior( predictors[i] );           }           cond += Math.log( pc );         }         else         {           for( i=0; i<len; ++i )           {             g.push( this._table.getConditional( predictors[i], className ) );             cond *= g[i];             p    *= numeratorOnly ? 1.0 : this._table.getPrior( predictors[i] );           }           cond *= pc;         }         prob  = numeratorOnly ? cond : cond/p;       }       gain = Math.log2(cond) - Math.log2(pc);       return {p:prob, gain:gain};     }     /**      * Clear all internal references a prepare the Bayes class to receive new data      *      * @return Nothing - all internal references are cleared - this can be used to prepare external references for garbage collection      */      , clear: function()      {        this._table = null;        this._invalidated = false;      }    }  }    return returnedModule;});